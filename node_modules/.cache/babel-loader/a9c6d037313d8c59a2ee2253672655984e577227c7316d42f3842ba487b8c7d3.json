{"ast":null,"code":"\"use strict\";\n\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketTransport = void 0;\nconst HeaderNames_1 = require(\"./HeaderNames\");\nconst ILogger_1 = require(\"./ILogger\");\nconst ITransport_1 = require(\"./ITransport\");\nconst Utils_1 = require(\"./Utils\");\n/** @private */\nclass WebSocketTransport {\n  constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n  async connect(url, transferFormat) {\n    Utils_1.Arg.isRequired(url, \"url\");\n    Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\n    Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\n    this._logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n    let token;\n    if (this._accessTokenFactory) {\n      token = await this._accessTokenFactory();\n    }\n    return new Promise((resolve, reject) => {\n      url = url.replace(/^http/, \"ws\");\n      let webSocket;\n      const cookies = this._httpClient.getCookieString(url);\n      let opened = false;\n      if (Utils_1.Platform.isNode || Utils_1.Platform.isReactNative) {\n        const headers = {};\n        const [name, value] = (0, Utils_1.getUserAgentHeader)();\n        headers[name] = value;\n        if (token) {\n          headers[HeaderNames_1.HeaderNames.Authorization] = `Bearer ${token}`;\n        }\n        if (cookies) {\n          headers[HeaderNames_1.HeaderNames.Cookie] = cookies;\n        }\n        // Only pass headers when in non-browser environments\n        webSocket = new this._webSocketConstructor(url, undefined, {\n          headers: {\n            ...headers,\n            ...this._headers\n          }\n        });\n      } else {\n        if (token) {\n          url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n        }\n      }\n      if (!webSocket) {\n        // Chrome is not happy with passing 'undefined' as protocol\n        webSocket = new this._webSocketConstructor(url);\n      }\n      if (transferFormat === ITransport_1.TransferFormat.Binary) {\n        webSocket.binaryType = \"arraybuffer\";\n      }\n      webSocket.onopen = _event => {\n        this._logger.log(ILogger_1.LogLevel.Information, `WebSocket connected to ${url}.`);\n        this._webSocket = webSocket;\n        opened = true;\n        resolve();\n      };\n      webSocket.onerror = event => {\n        let error = null;\n        // ErrorEvent is a browser only type we need to check if the type exists before using it\n        if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n          error = event.error;\n        } else {\n          error = \"There was an error with the transport\";\n        }\n        this._logger.log(ILogger_1.LogLevel.Information, `(WebSockets transport) ${error}.`);\n      };\n      webSocket.onmessage = message => {\n        this._logger.log(ILogger_1.LogLevel.Trace, `(WebSockets transport) data received. ${(0, Utils_1.getDataDetail)(message.data, this._logMessageContent)}.`);\n        if (this.onreceive) {\n          try {\n            this.onreceive(message.data);\n          } catch (error) {\n            this._close(error);\n            return;\n          }\n        }\n      };\n      webSocket.onclose = event => {\n        // Don't call close handler if connection was never established\n        // We'll reject the connect call instead\n        if (opened) {\n          this._close(event);\n        } else {\n          let error = null;\n          // ErrorEvent is a browser only type we need to check if the type exists before using it\n          if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n            error = event.error;\n          } else {\n            error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n          }\n          reject(new Error(error));\n        }\n      };\n    });\n  }\n  send(data) {\n    if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n      this._logger.log(ILogger_1.LogLevel.Trace, `(WebSockets transport) sending data. ${(0, Utils_1.getDataDetail)(data, this._logMessageContent)}.`);\n      this._webSocket.send(data);\n      return Promise.resolve();\n    }\n    return Promise.reject(\"WebSocket is not in the OPEN state\");\n  }\n  stop() {\n    if (this._webSocket) {\n      // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n      // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n      this._close(undefined);\n    }\n    return Promise.resolve();\n  }\n  _close(event) {\n    // webSocket will be null if the transport did not start successfully\n    if (this._webSocket) {\n      // Clear websocket handlers because we are considering the socket closed now\n      this._webSocket.onclose = () => {};\n      this._webSocket.onmessage = () => {};\n      this._webSocket.onerror = () => {};\n      this._webSocket.close();\n      this._webSocket = undefined;\n    }\n    this._logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n    if (this.onclose) {\n      if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n        this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\n      } else if (event instanceof Error) {\n        this.onclose(event);\n      } else {\n        this.onclose();\n      }\n    }\n  }\n  _isCloseEvent(event) {\n    return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n  }\n}\nexports.WebSocketTransport = WebSocketTransport;","map":{"version":3,"names":["HeaderNames_1","require","ILogger_1","ITransport_1","Utils_1","WebSocketTransport","constructor","httpClient","accessTokenFactory","logger","logMessageContent","webSocketConstructor","headers","_logger","_accessTokenFactory","_logMessageContent","_webSocketConstructor","_httpClient","onreceive","onclose","_headers","connect","url","transferFormat","Arg","isRequired","isIn","TransferFormat","log","LogLevel","Trace","token","Promise","resolve","reject","replace","webSocket","cookies","getCookieString","opened","Platform","isNode","isReactNative","name","value","getUserAgentHeader","HeaderNames","Authorization","Cookie","undefined","indexOf","encodeURIComponent","Binary","binaryType","onopen","_event","Information","_webSocket","onerror","event","error","ErrorEvent","onmessage","message","getDataDetail","data","_close","Error","send","readyState","OPEN","stop","close","_isCloseEvent","wasClean","code","reason","exports"],"sources":["M:\\chord-site\\node_modules\\@microsoft\\signalr\\src\\WebSocketTransport.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly _logger: ILogger;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logMessageContent: boolean;\r\n    private readonly _webSocketConstructor: WebSocketConstructor;\r\n    private readonly _httpClient: HttpClient;\r\n    private _webSocket?: WebSocket;\r\n    private _headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        let token: string;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers: {[k: string]: string} = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else\r\n            {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            webSocket.onopen = (_event: Event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the endpoint may not be a SignalR endpoint,\"\r\n                        + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(event: CloseEvent | Error | unknown): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => {};\r\n            this._webSocket.onmessage = () => {};\r\n            this._webSocket.onerror = () => {};\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}