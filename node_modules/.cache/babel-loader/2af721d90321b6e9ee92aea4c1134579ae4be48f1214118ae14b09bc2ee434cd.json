{"ast":null,"code":"\"use strict\";\n\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchHttpClient = void 0;\nconst Errors_1 = require(\"./Errors\");\nconst HttpClient_1 = require(\"./HttpClient\");\nconst ILogger_1 = require(\"./ILogger\");\nconst Utils_1 = require(\"./Utils\");\nclass FetchHttpClient extends HttpClient_1.HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n    // Node added a fetch implementation to the global scope starting in v18.\n    // We need to add a cookie jar in node to be able to share cookies with WebSocket\n    if (typeof fetch === \"undefined\" || Utils_1.Platform.isNode) {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n      this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      if (typeof fetch === \"undefined\") {\n        this._fetchType = requireFunc(\"node-fetch\");\n      } else {\n        // Use fetch from Node if available\n        this._fetchType = fetch;\n      }\n      // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n      this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else {\n      this._fetchType = fetch.bind((0, Utils_1.getGlobalThis)());\n    }\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n      this._abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      this._abortControllerType = AbortController;\n    }\n  }\n  /** @inheritDoc */\n  async send(request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      throw new Errors_1.AbortError();\n    }\n    if (!request.method) {\n      throw new Error(\"No method defined.\");\n    }\n    if (!request.url) {\n      throw new Error(\"No url defined.\");\n    }\n    const abortController = new this._abortControllerType();\n    let error;\n    // Hook our abortSignal into the abort controller\n    if (request.abortSignal) {\n      request.abortSignal.onabort = () => {\n        abortController.abort();\n        error = new Errors_1.AbortError();\n      };\n    }\n    // If a timeout has been passed in, setup a timeout to call abort\n    // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n    let timeoutId = null;\n    if (request.timeout) {\n      const msTimeout = request.timeout;\n      timeoutId = setTimeout(() => {\n        abortController.abort();\n        this._logger.log(ILogger_1.LogLevel.Warning, `Timeout from HTTP request.`);\n        error = new Errors_1.TimeoutError();\n      }, msTimeout);\n    }\n    if (request.content === \"\") {\n      request.content = undefined;\n    }\n    if (request.content) {\n      // Explicitly setting the Content-Type header for React Native on Android platform.\n      request.headers = request.headers || {};\n      if ((0, Utils_1.isArrayBuffer)(request.content)) {\n        request.headers[\"Content-Type\"] = \"application/octet-stream\";\n      } else {\n        request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    }\n    let response;\n    try {\n      response = await this._fetchType(request.url, {\n        body: request.content,\n        cache: \"no-cache\",\n        credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n        headers: {\n          \"X-Requested-With\": \"XMLHttpRequest\",\n          ...request.headers\n        },\n        method: request.method,\n        mode: \"cors\",\n        redirect: \"follow\",\n        signal: abortController.signal\n      });\n    } catch (e) {\n      if (error) {\n        throw error;\n      }\n      this._logger.log(ILogger_1.LogLevel.Warning, `Error from HTTP request. ${e}.`);\n      throw e;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      if (request.abortSignal) {\n        request.abortSignal.onabort = null;\n      }\n    }\n    if (!response.ok) {\n      const errorMessage = await deserializeContent(response, \"text\");\n      throw new Errors_1.HttpError(errorMessage || response.statusText, response.status);\n    }\n    const content = deserializeContent(response, request.responseType);\n    const payload = await content;\n    return new HttpClient_1.HttpResponse(response.status, response.statusText, payload);\n  }\n  getCookieString(url) {\n    let cookies = \"\";\n    if (Utils_1.Platform.isNode && this._jar) {\n      // @ts-ignore: unused variable\n      this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n    }\n    return cookies;\n  }\n}\nexports.FetchHttpClient = FetchHttpClient;\nfunction deserializeContent(response, responseType) {\n  let content;\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n    case \"text\":\n      content = response.text();\n      break;\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(`${responseType} is not supported.`);\n    default:\n      content = response.text();\n      break;\n  }\n  return content;\n}","map":{"version":3,"names":["Errors_1","require","HttpClient_1","ILogger_1","Utils_1","FetchHttpClient","HttpClient","constructor","logger","_logger","fetch","Platform","isNode","requireFunc","__webpack_require__","__non_webpack_require__","_jar","CookieJar","_fetchType","bind","getGlobalThis","AbortController","_abortControllerType","send","request","abortSignal","aborted","AbortError","method","Error","url","abortController","error","onabort","abort","timeoutId","timeout","msTimeout","setTimeout","log","LogLevel","Warning","TimeoutError","content","undefined","headers","isArrayBuffer","response","body","cache","credentials","withCredentials","mode","redirect","signal","e","clearTimeout","ok","errorMessage","deserializeContent","HttpError","statusText","status","responseType","payload","HttpResponse","getCookieString","cookies","getCookies","c","join","exports","arrayBuffer","text"],"sources":["M:\\chord-site\\node_modules\\@microsoft\\signalr\\src\\FetchHttpClient.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport { CookieJar } from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis, isArrayBuffer } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly _abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly _fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly _jar?: CookieJar;\r\n\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n\r\n        // Node added a fetch implementation to the global scope starting in v18.\r\n        // We need to add a cookie jar in node to be able to share cookies with WebSocket\r\n        if (typeof fetch === \"undefined\" || Platform.isNode) {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n\r\n            if (typeof fetch === \"undefined\") {\r\n                this._fetchType = requireFunc(\"node-fetch\");\r\n            } else {\r\n                // Use fetch from Node if available\r\n                this._fetchType = fetch;\r\n            }\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        } else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this._abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            } else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this._fetchType(request.url!, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\") as string;\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}