{"ast":null,"code":"\"use strict\";\n\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServerSentEventsTransport = void 0;\nconst ILogger_1 = require(\"./ILogger\");\nconst ITransport_1 = require(\"./ITransport\");\nconst Utils_1 = require(\"./Utils\");\n/** @private */\nclass ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  async connect(url, transferFormat) {\n    Utils_1.Arg.isRequired(url, \"url\");\n    Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\n    Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\n    this._logger.log(ILogger_1.LogLevel.Trace, \"(SSE transport) Connecting.\");\n    // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n    this._url = url;\n    if (this._accessToken) {\n      url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\n    }\n    return new Promise((resolve, reject) => {\n      let opened = false;\n      if (transferFormat !== ITransport_1.TransferFormat.Text) {\n        reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n        return;\n      }\n      let eventSource;\n      if (Utils_1.Platform.isBrowser || Utils_1.Platform.isWebWorker) {\n        eventSource = new this._options.EventSource(url, {\n          withCredentials: this._options.withCredentials\n        });\n      } else {\n        // Non-browser passes cookies via the dictionary\n        const cookies = this._httpClient.getCookieString(url);\n        const headers = {};\n        headers.Cookie = cookies;\n        const [name, value] = (0, Utils_1.getUserAgentHeader)();\n        headers[name] = value;\n        eventSource = new this._options.EventSource(url, {\n          withCredentials: this._options.withCredentials,\n          headers: {\n            ...headers,\n            ...this._options.headers\n          }\n        });\n      }\n      try {\n        eventSource.onmessage = e => {\n          if (this.onreceive) {\n            try {\n              this._logger.log(ILogger_1.LogLevel.Trace, `(SSE transport) data received. ${(0, Utils_1.getDataDetail)(e.data, this._options.logMessageContent)}.`);\n              this.onreceive(e.data);\n            } catch (error) {\n              this._close(error);\n              return;\n            }\n          }\n        };\n        // @ts-ignore: not using event on purpose\n        eventSource.onerror = e => {\n          // EventSource doesn't give any useful information about server side closes.\n          if (opened) {\n            this._close();\n          } else {\n            reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n          }\n        };\n        eventSource.onopen = () => {\n          this._logger.log(ILogger_1.LogLevel.Information, `SSE connected to ${this._url}`);\n          this._eventSource = eventSource;\n          opened = true;\n          resolve();\n        };\n      } catch (e) {\n        reject(e);\n        return;\n      }\n    });\n  }\n  async send(data) {\n    if (!this._eventSource) {\n      return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n    }\n    return (0, Utils_1.sendMessage)(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\n  }\n  stop() {\n    this._close();\n    return Promise.resolve();\n  }\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n      this._eventSource = undefined;\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n}\nexports.ServerSentEventsTransport = ServerSentEventsTransport;","map":{"version":3,"names":["ILogger_1","require","ITransport_1","Utils_1","ServerSentEventsTransport","constructor","httpClient","accessToken","logger","options","_httpClient","_accessToken","_logger","_options","onreceive","onclose","connect","url","transferFormat","Arg","isRequired","isIn","TransferFormat","log","LogLevel","Trace","_url","indexOf","encodeURIComponent","Promise","resolve","reject","opened","Text","Error","eventSource","Platform","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","name","value","getUserAgentHeader","onmessage","e","getDataDetail","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","send","sendMessage","stop","close","undefined","exports"],"sources":["M:\\chord-site\\node_modules\\@microsoft\\signalr\\src\\ServerSentEventsTransport.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessToken: string | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private _eventSource?: EventSource;\r\n    private _url?: string;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error | unknown) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessToken: string | undefined, logger: ILogger,\r\n                options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent!)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e: Event) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    } else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(e?: Error | unknown) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}