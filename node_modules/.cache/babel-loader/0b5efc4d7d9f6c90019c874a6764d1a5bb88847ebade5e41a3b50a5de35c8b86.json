{"ast":null,"code":"\"use strict\";\n\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultHttpClient = void 0;\nconst Errors_1 = require(\"./Errors\");\nconst FetchHttpClient_1 = require(\"./FetchHttpClient\");\nconst HttpClient_1 = require(\"./HttpClient\");\nconst Utils_1 = require(\"./Utils\");\nconst XhrHttpClient_1 = require(\"./XhrHttpClient\");\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\nclass DefaultHttpClient extends HttpClient_1.HttpClient {\n  /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\n  constructor(logger) {\n    super();\n    if (typeof fetch !== \"undefined\" || Utils_1.Platform.isNode) {\n      this._httpClient = new FetchHttpClient_1.FetchHttpClient(logger);\n    } else if (typeof XMLHttpRequest !== \"undefined\") {\n      this._httpClient = new XhrHttpClient_1.XhrHttpClient(logger);\n    } else {\n      throw new Error(\"No usable HttpClient found.\");\n    }\n  }\n  /** @inheritDoc */\n  send(request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      return Promise.reject(new Errors_1.AbortError());\n    }\n    if (!request.method) {\n      return Promise.reject(new Error(\"No method defined.\"));\n    }\n    if (!request.url) {\n      return Promise.reject(new Error(\"No url defined.\"));\n    }\n    return this._httpClient.send(request);\n  }\n  getCookieString(url) {\n    return this._httpClient.getCookieString(url);\n  }\n}\nexports.DefaultHttpClient = DefaultHttpClient;","map":{"version":3,"names":["Errors_1","require","FetchHttpClient_1","HttpClient_1","Utils_1","XhrHttpClient_1","DefaultHttpClient","HttpClient","constructor","logger","fetch","Platform","isNode","_httpClient","FetchHttpClient","XMLHttpRequest","XhrHttpClient","Error","send","request","abortSignal","aborted","Promise","reject","AbortError","method","url","getCookieString","exports"],"sources":["M:\\chord-site\\node_modules\\@microsoft\\signalr\\src\\DefaultHttpClient.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    private readonly _httpClient: HttpClient;\r\n\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        } else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return this._httpClient.send(request);\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n"],"mappings":";;AAAA;AACA;;;;;AAEA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AAEA,MAAAG,OAAA,GAAAH,OAAA;AACA,MAAAI,eAAA,GAAAJ,OAAA;AAEA;AACA,MAAaK,iBAAkB,SAAQH,YAAA,CAAAI,UAAU;EAG7C;EACAC,YAAmBC,MAAe;IAC9B,KAAK,EAAE;IAEP,IAAI,OAAOC,KAAK,KAAK,WAAW,IAAIN,OAAA,CAAAO,QAAQ,CAACC,MAAM,EAAE;MACjD,IAAI,CAACC,WAAW,GAAG,IAAIX,iBAAA,CAAAY,eAAe,CAACL,MAAM,CAAC;KACjD,MAAM,IAAI,OAAOM,cAAc,KAAK,WAAW,EAAE;MAC9C,IAAI,CAACF,WAAW,GAAG,IAAIR,eAAA,CAAAW,aAAa,CAACP,MAAM,CAAC;KAC/C,MAAM;MACH,MAAM,IAAIQ,KAAK,CAAC,6BAA6B,CAAC;;EAEtD;EAEA;EACOC,IAAIA,CAACC,OAAoB;IAC5B;IACA,IAAIA,OAAO,CAACC,WAAW,IAAID,OAAO,CAACC,WAAW,CAACC,OAAO,EAAE;MACpD,OAAOC,OAAO,CAACC,MAAM,CAAC,IAAIvB,QAAA,CAAAwB,UAAU,EAAE,CAAC;;IAG3C,IAAI,CAACL,OAAO,CAACM,MAAM,EAAE;MACjB,OAAOH,OAAO,CAACC,MAAM,CAAC,IAAIN,KAAK,CAAC,oBAAoB,CAAC,CAAC;;IAE1D,IAAI,CAACE,OAAO,CAACO,GAAG,EAAE;MACd,OAAOJ,OAAO,CAACC,MAAM,CAAC,IAAIN,KAAK,CAAC,iBAAiB,CAAC,CAAC;;IAGvD,OAAO,IAAI,CAACJ,WAAW,CAACK,IAAI,CAACC,OAAO,CAAC;EACzC;EAEOQ,eAAeA,CAACD,GAAW;IAC9B,OAAO,IAAI,CAACb,WAAW,CAACc,eAAe,CAACD,GAAG,CAAC;EAChD;;AAnCJE,OAAA,CAAAtB,iBAAA,GAAAA,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}